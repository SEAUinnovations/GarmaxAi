{
  "version": 3,
  "sources": ["../../iac/lambda-handlers/restoreOrchestrator/index.ts"],
  "sourcesContent": ["import { RDSClient, StartDBClusterCommand, DescribeDBClustersCommand } from '@aws-sdk/client-rds';\nimport {\n  ElastiCacheClient,\n  CreateCacheClusterCommand,\n  DescribeCacheClustersCommand,\n} from '@aws-sdk/client-elasticache';\nimport { ECSClient, UpdateServiceCommand } from '@aws-sdk/client-ecs';\nimport { LambdaClient, InvokeCommand } from '@aws-sdk/client-lambda';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, PutCommand } from '@aws-sdk/lib-dynamodb';\nimport { SSMClient, GetParameterCommand, DeleteParameterCommand } from '@aws-sdk/client-ssm';\nimport { SNSClient, PublishCommand } from '@aws-sdk/client-sns';\n\nconst rdsClient = new RDSClient({});\nconst elasticacheClient = new ElastiCacheClient({});\nconst ecsClient = new ECSClient({});\nconst lambdaClient = new LambdaClient({});\nconst ddbClient = DynamoDBDocumentClient.from(new DynamoDBClient({}));\nconst ssmClient = new SSMClient({});\nconst snsClient = new SNSClient({});\n\ninterface RestoreEvent {\n  resource: 'rds' | 'elasticache' | 'ecs' | 'nat-gateway' | 'all';\n  stage: string;\n  wait?: boolean; // Whether to wait for resource to be fully available\n}\n\n/**\n * Start RDS Aurora cluster\n */\nasync function startRDS(stage: string, wait: boolean = false): Promise<{ status: string; endpoint?: string }> {\n  // Retrieve cluster ID from Parameter Store\n  const param = await ssmClient.send(\n    new GetParameterCommand({\n      Name: `/garmaxai/idle-state/${stage}/rds-cluster`,\n    })\n  ).catch(() => null);\n\n  if (!param?.Parameter?.Value) {\n    console.log('No RDS cluster to restore');\n    return { status: 'not-found' };\n  }\n\n  const clusterId = param.Parameter.Value;\n  console.log(`Starting RDS cluster: ${clusterId}`);\n\n  // Check current status\n  const describeResponse = await rdsClient.send(\n    new DescribeDBClustersCommand({\n      DBClusterIdentifier: clusterId,\n    })\n  );\n\n  const currentStatus = describeResponse.DBClusters?.[0]?.Status;\n  if (currentStatus === 'available') {\n    console.log(`RDS cluster already available`);\n    return {\n      status: 'available',\n      endpoint: describeResponse.DBClusters?.[0]?.Endpoint,\n    };\n  }\n\n  if (currentStatus !== 'stopped') {\n    console.log(`RDS cluster in ${currentStatus} state, cannot start`);\n    return { status: currentStatus || 'unknown' };\n  }\n\n  // Start the cluster\n  await rdsClient.send(\n    new StartDBClusterCommand({\n      DBClusterIdentifier: clusterId,\n    })\n  );\n\n  // Update DynamoDB state\n  await updateResourceState(`RDS_CLUSTER#${stage}`, stage, 'STARTING', {\n    clusterId,\n    startedAt: new Date().toISOString(),\n  });\n\n  console.log(`RDS cluster start initiated: ${clusterId}`);\n\n  // Optionally wait for cluster to become available\n  if (wait) {\n    console.log('Waiting for RDS cluster to become available...');\n    let attempts = 0;\n    const maxAttempts = 40; // 20 minutes max\n\n    while (attempts < maxAttempts) {\n      await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30 seconds\n      attempts++;\n\n      const statusResponse = await rdsClient.send(\n        new DescribeDBClustersCommand({\n          DBClusterIdentifier: clusterId,\n        })\n      );\n\n      const status = statusResponse.DBClusters?.[0]?.Status;\n      if (status === 'available') {\n        await updateResourceState(`RDS_CLUSTER#${stage}`, stage, 'AVAILABLE', {\n          clusterId,\n          availableAt: new Date().toISOString(),\n        });\n        return {\n          status: 'available',\n          endpoint: statusResponse.DBClusters?.[0]?.Endpoint,\n        };\n      }\n\n      console.log(`RDS cluster status: ${status} (attempt ${attempts}/${maxAttempts})`);\n    }\n\n    throw new Error('RDS cluster did not become available within 20 minutes');\n  }\n\n  return { status: 'starting' };\n}\n\n/**\n * Restore ElastiCache cluster\n */\nasync function restoreElastiCache(stage: string, wait: boolean = false): Promise<{ status: string }> {\n  const redisClusterId = process.env.REDIS_CLUSTER_NAME || `garmaxai-redis-${stage}`;\n\n  // Check if cluster already exists\n  const existingCluster = await elasticacheClient.send(\n    new DescribeCacheClustersCommand({\n      CacheClusterId: redisClusterId,\n    })\n  ).catch(() => null);\n\n  if (existingCluster?.CacheClusters && existingCluster.CacheClusters.length > 0) {\n    const status = existingCluster.CacheClusters[0].CacheClusterStatus;\n    console.log(`ElastiCache cluster already exists with status: ${status}`);\n    return { status: status || 'unknown' };\n  }\n\n  console.log(`Restoring ElastiCache cluster: ${redisClusterId}`);\n\n  // Get configuration from environment/Parameter Store\n  const subnetGroup = process.env.REDIS_SUBNET_GROUP || `garmaxai-redis-subnet-${stage}`;\n  const securityGroup = process.env.REDIS_SECURITY_GROUP;\n\n  if (stage === 'PROD') {\n    // Restore from snapshot for PROD\n    const snapshotParam = await ssmClient.send(\n      new GetParameterCommand({\n        Name: `/garmaxai/idle-state/${stage}/redis-snapshot`,\n      })\n    ).catch(() => null);\n\n    if (snapshotParam?.Parameter?.Value) {\n      const snapshotName = snapshotParam.Parameter.Value;\n      console.log(`Restoring from snapshot: ${snapshotName}`);\n\n      await elasticacheClient.send(\n        new CreateCacheClusterCommand({\n          CacheClusterId: redisClusterId,\n          SnapshotName: snapshotName,\n          CacheNodeType: 'cache.t4g.micro',\n          Engine: 'redis',\n          CacheSubnetGroupName: subnetGroup,\n          SecurityGroupIds: securityGroup ? [securityGroup] : undefined,\n        })\n      );\n    } else {\n      console.log('No snapshot found for PROD, creating fresh cluster');\n      await createFreshRedisCluster(redisClusterId, subnetGroup, securityGroup);\n    }\n  } else {\n    // Create fresh cluster for DEV/QA\n    console.log('Creating fresh ElastiCache cluster for DEV/QA');\n    await createFreshRedisCluster(redisClusterId, subnetGroup, securityGroup);\n  }\n\n  // Update DynamoDB state\n  await updateResourceState(`ELASTICACHE#${stage}`, stage, 'CREATING', {\n    clusterId: redisClusterId,\n    restoredAt: new Date().toISOString(),\n  });\n\n  console.log(`ElastiCache restore initiated: ${redisClusterId}`);\n  return { status: 'creating' };\n}\n\nasync function createFreshRedisCluster(clusterId: string, subnetGroup: string, securityGroup?: string): Promise<void> {\n  await elasticacheClient.send(\n    new CreateCacheClusterCommand({\n      CacheClusterId: clusterId,\n      CacheNodeType: 'cache.t4g.micro',\n      Engine: 'redis',\n      EngineVersion: '7.1',\n      NumCacheNodes: 1,\n      CacheSubnetGroupName: subnetGroup,\n      SecurityGroupIds: securityGroup ? [securityGroup] : undefined,\n    })\n  );\n}\n\n/**\n * Scale up ECS services\n */\nasync function scaleUpECS(stage: string): Promise<{ servicesRestored: number }> {\n  const ecsCluster = process.env.ECS_CLUSTER_NAME || `GarmaxAi-${stage}`;\n\n  // Retrieve service ARNs from Parameter Store\n  const param = await ssmClient.send(\n    new GetParameterCommand({\n      Name: `/garmaxai/idle-state/${stage}/ecs-services`,\n    })\n  ).catch(() => null);\n\n  if (!param?.Parameter?.Value) {\n    console.log('No ECS services to restore');\n    return { servicesRestored: 0 };\n  }\n\n  const serviceArns = param.Parameter.Value.split(',');\n  console.log(`Scaling up ${serviceArns.length} ECS services`);\n\n  for (const serviceArn of serviceArns) {\n    const serviceName = serviceArn.split('/').pop()!;\n    console.log(`Scaling service to 1: ${serviceName}`);\n\n    await ecsClient.send(\n      new UpdateServiceCommand({\n        cluster: ecsCluster,\n        service: serviceName,\n        desiredCount: 1,\n      })\n    );\n  }\n\n  // Update DynamoDB state\n  await updateResourceState(`ECS_CLUSTER#${stage}`, stage, 'ACTIVE', {\n    cluster: ecsCluster,\n    serviceCount: serviceArns.length,\n    restoredAt: new Date().toISOString(),\n  });\n\n  console.log(`Scaled up ${serviceArns.length} ECS services`);\n  return { servicesRestored: serviceArns.length };\n}\n\n/**\n * Restore NAT Gateway\n */\nasync function restoreNATGateway(stage: string): Promise<void> {\n  const functionName = process.env.NAT_MANAGER_FUNCTION_NAME || `GarmaxAi-NATManager-${stage}`;\n  const vpcId = process.env.VPC_ID;\n\n  if (!vpcId) {\n    throw new Error('VPC_ID environment variable not set');\n  }\n\n  console.log(`Invoking NAT Gateway manager for VPC: ${vpcId}`);\n\n  const response = await lambdaClient.send(\n    new InvokeCommand({\n      FunctionName: functionName,\n      Payload: JSON.stringify({\n        action: 'restore',\n        vpcId,\n      }),\n    })\n  );\n\n  const result = JSON.parse(new TextDecoder().decode(response.Payload));\n  console.log(`NAT Gateway manager response:`, result);\n\n  if (result.statusCode !== 200) {\n    throw new Error(`NAT Gateway restore failed: ${result.error}`);\n  }\n\n  console.log(`NAT Gateway restore completed`);\n}\n\n/**\n * Update resource state in DynamoDB\n */\nasync function updateResourceState(resourceKey: string, stage: string, state: string, metadata: any): Promise<void> {\n  const stateTableName = process.env.STATE_TABLE_NAME || 'GarmaxAi-ResourceState';\n\n  await ddbClient.send(\n    new PutCommand({\n      TableName: stateTableName,\n      Item: {\n        resourceKey,\n        timestamp: Date.now(),\n        stage,\n        currentState: state,\n        metadata,\n        ttl: Math.floor(Date.now() / 1000) + 90 * 24 * 60 * 60, // 90 days\n      },\n    })\n  );\n}\n\n/**\n * Send restore completion notification\n */\nasync function sendRestoreNotification(stage: string, results: any, duration: number): Promise<void> {\n  const topicArn = process.env.SNS_TOPIC_ARN;\n  if (!topicArn) return;\n\n  const message = `\u2705 GarmaxAI ${stage} Environment Restore Completed\n\n\uD83D\uDCCA Restore Summary:\n\u2022 Duration: ${Math.floor(duration / 60)}m ${duration % 60}s\n\u2022 RDS Status: ${results.rds?.status || 'N/A'}\n\u2022 ElastiCache Status: ${results.elasticache?.status || 'N/A'}\n\u2022 ECS Services: ${results.ecs?.servicesRestored || 0} restored\n\u2022 NAT Gateway: ${results.natGateway ? 'Restored' : 'N/A'}\n\n\uD83D\uDE80 System is ready for production traffic!\n\nTimestamp: ${new Date().toISOString()}`;\n\n  await snsClient.send(\n    new PublishCommand({\n      TopicArn: topicArn,\n      Subject: `\u2705 GarmaxAI ${stage} - Restore Completed`,\n      Message: message,\n    })\n  );\n}\n\n/**\n * Lambda handler\n */\nexport const handler = async (event: RestoreEvent): Promise<any> => {\n  console.log('Restore orchestrator invoked:', JSON.stringify(event, null, 2));\n  const startTime = Date.now();\n\n  try {\n    const { resource, stage, wait = false } = event;\n\n    let results: any = {};\n\n    switch (resource) {\n      case 'rds':\n        results.rds = await startRDS(stage, wait);\n        break;\n\n      case 'elasticache':\n        results.elasticache = await restoreElastiCache(stage, wait);\n        break;\n\n      case 'ecs':\n        results.ecs = await scaleUpECS(stage);\n        break;\n\n      case 'nat-gateway':\n        await restoreNATGateway(stage);\n        results.natGateway = true;\n        break;\n\n      case 'all':\n        // Execute all restores in parallel\n        const [rdsResult, elasticacheResult, ecsResult] = await Promise.all([\n          startRDS(stage, wait),\n          restoreElastiCache(stage, wait),\n          scaleUpECS(stage),\n          restoreNATGateway(stage),\n        ]);\n\n        results = {\n          rds: rdsResult,\n          elasticache: elasticacheResult,\n          ecs: ecsResult,\n          natGateway: true,\n        };\n        break;\n\n      default:\n        throw new Error(`Unknown resource: ${resource}`);\n    }\n\n    // Clean up idle state parameters\n    const paramsToDelete = [\n      `/garmaxai/idle-state/${stage}/timestamp`,\n      `/garmaxai/idle-state/${stage}/rds-cluster`,\n      `/garmaxai/idle-state/${stage}/redis-snapshot`,\n      `/garmaxai/idle-state/${stage}/ecs-services`,\n    ];\n\n    for (const paramName of paramsToDelete) {\n      await ssmClient.send(new DeleteParameterCommand({ Name: paramName })).catch(() => {});\n    }\n\n    const duration = Math.floor((Date.now() - startTime) / 1000);\n    await sendRestoreNotification(stage, results, duration);\n\n    return {\n      statusCode: 200,\n      message: `Restore completed for ${resource} in ${stage}`,\n      results,\n      duration,\n      timestamp: new Date().toISOString(),\n    };\n  } catch (error) {\n    console.error('Restore orchestrator error:', error);\n    throw error;\n  }\n};\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "handler", "__toCommonJS", "import_client_rds", "import_client_elasticache", "import_client_ecs", "import_client_lambda", "import_client_dynamodb", "import_lib_dynamodb", "import_client_ssm", "import_client_sns", "rdsClient", "elasticacheClient", "ecsClient", "lambdaClient", "ddbClient", "ssmClient", "snsClient", "startRDS", "stage", "wait", "param", "clusterId", "describeResponse", "currentStatus", "updateResourceState", "attempts", "maxAttempts", "resolve", "statusResponse", "status", "restoreElastiCache", "redisClusterId", "existingCluster", "subnetGroup", "securityGroup", "snapshotParam", "snapshotName", "createFreshRedisCluster", "scaleUpECS", "ecsCluster", "serviceArns", "serviceArn", "serviceName", "restoreNATGateway", "functionName", "vpcId", "response", "result", "resourceKey", "state", "metadata", "stateTableName", "sendRestoreNotification", "results", "duration", "topicArn", "message", "event", "startTime", "resource", "rdsResult", "elasticacheResult", "ecsResult", "paramsToDelete", "paramName", "error"]
}
