"use strict";var R=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var P=Object.prototype.hasOwnProperty;var G=(t,a)=>{for(var s in a)R(t,s,{get:a[s],enumerable:!0})},_=(t,a,s,e)=>{if(a&&typeof a=="object"||typeof a=="function")for(let r of T(a))!P.call(t,r)&&r!==s&&R(t,r,{get:()=>a[r],enumerable:!(e=b(a,r))||e.enumerable});return t};var x=t=>_(R({},"__esModule",{value:!0}),t);var L={};G(L,{handler:()=>M});module.exports=x(L);var l=require("@aws-sdk/client-rds"),u=require("@aws-sdk/client-elasticache"),w=require("@aws-sdk/client-ecs"),S=require("@aws-sdk/client-lambda"),I=require("@aws-sdk/client-dynamodb"),g=require("@aws-sdk/lib-dynamodb"),c=require("@aws-sdk/client-ssm"),p=require("@aws-sdk/client-sns"),D=new l.RDSClient({}),E=new u.ElastiCacheClient({}),O=new w.ECSClient({}),B=new S.LambdaClient({}),U=g.DynamoDBDocumentClient.from(new I.DynamoDBClient({})),h=new c.SSMClient({}),V=new p.SNSClient({});async function N(t,a=!1){let s=await h.send(new c.GetParameterCommand({Name:`/garmaxai/idle-state/${t}/rds-cluster`})).catch(()=>null);if(!s?.Parameter?.Value)return console.log("No RDS cluster to restore"),{status:"not-found"};let e=s.Parameter.Value;console.log(`Starting RDS cluster: ${e}`);let r=await D.send(new l.DescribeDBClustersCommand({DBClusterIdentifier:e})),n=r.DBClusters?.[0]?.Status;if(n==="available")return console.log("RDS cluster already available"),{status:"available",endpoint:r.DBClusters?.[0]?.Endpoint};if(n!=="stopped")return console.log(`RDS cluster in ${n} state, cannot start`),{status:n||"unknown"};if(await D.send(new l.StartDBClusterCommand({DBClusterIdentifier:e})),await C(`RDS_CLUSTER#${t}`,t,"STARTING",{clusterId:e,startedAt:new Date().toISOString()}),console.log(`RDS cluster start initiated: ${e}`),a){console.log("Waiting for RDS cluster to become available...");let o=0,i=40;for(;o<i;){await new Promise(f=>setTimeout(f,3e4)),o++;let m=await D.send(new l.DescribeDBClustersCommand({DBClusterIdentifier:e})),d=m.DBClusters?.[0]?.Status;if(d==="available")return await C(`RDS_CLUSTER#${t}`,t,"AVAILABLE",{clusterId:e,availableAt:new Date().toISOString()}),{status:"available",endpoint:m.DBClusters?.[0]?.Endpoint};console.log(`RDS cluster status: ${d} (attempt ${o}/${i})`)}throw new Error("RDS cluster did not become available within 20 minutes")}return{status:"starting"}}async function v(t,a=!1){let s=process.env.REDIS_CLUSTER_NAME||`garmaxai-redis-${t}`,e=await E.send(new u.DescribeCacheClustersCommand({CacheClusterId:s})).catch(()=>null);if(e?.CacheClusters&&e.CacheClusters.length>0){let o=e.CacheClusters[0].CacheClusterStatus;return console.log(`ElastiCache cluster already exists with status: ${o}`),{status:o||"unknown"}}console.log(`Restoring ElastiCache cluster: ${s}`);let r=process.env.REDIS_SUBNET_GROUP||`garmaxai-redis-subnet-${t}`,n=process.env.REDIS_SECURITY_GROUP;if(t==="PROD"){let o=await h.send(new c.GetParameterCommand({Name:`/garmaxai/idle-state/${t}/redis-snapshot`})).catch(()=>null);if(o?.Parameter?.Value){let i=o.Parameter.Value;console.log(`Restoring from snapshot: ${i}`),await E.send(new u.CreateCacheClusterCommand({CacheClusterId:s,SnapshotName:i,CacheNodeType:"cache.t4g.micro",Engine:"redis",CacheSubnetGroupName:r,SecurityGroupIds:n?[n]:void 0}))}else console.log("No snapshot found for PROD, creating fresh cluster"),await A(s,r,n)}else console.log("Creating fresh ElastiCache cluster for DEV/QA"),await A(s,r,n);return await C(`ELASTICACHE#${t}`,t,"CREATING",{clusterId:s,restoredAt:new Date().toISOString()}),console.log(`ElastiCache restore initiated: ${s}`),{status:"creating"}}async function A(t,a,s){await E.send(new u.CreateCacheClusterCommand({CacheClusterId:t,CacheNodeType:"cache.t4g.micro",Engine:"redis",EngineVersion:"7.1",NumCacheNodes:1,CacheSubnetGroupName:a,SecurityGroupIds:s?[s]:void 0}))}async function $(t){let a=process.env.ECS_CLUSTER_NAME||`GarmaxAi-${t}`,s=await h.send(new c.GetParameterCommand({Name:`/garmaxai/idle-state/${t}/ecs-services`})).catch(()=>null);if(!s?.Parameter?.Value)return console.log("No ECS services to restore"),{servicesRestored:0};let e=s.Parameter.Value.split(",");console.log(`Scaling up ${e.length} ECS services`);for(let r of e){let n=r.split("/").pop();console.log(`Scaling service to 1: ${n}`),await O.send(new w.UpdateServiceCommand({cluster:a,service:n,desiredCount:1}))}return await C(`ECS_CLUSTER#${t}`,t,"ACTIVE",{cluster:a,serviceCount:e.length,restoredAt:new Date().toISOString()}),console.log(`Scaled up ${e.length} ECS services`),{servicesRestored:e.length}}async function y(t){let a=process.env.NAT_MANAGER_FUNCTION_NAME||`GarmaxAi-NATManager-${t}`,s=process.env.VPC_ID;if(!s)throw new Error("VPC_ID environment variable not set");console.log(`Invoking NAT Gateway manager for VPC: ${s}`);let e=await B.send(new S.InvokeCommand({FunctionName:a,Payload:JSON.stringify({action:"restore",vpcId:s})})),r=JSON.parse(new TextDecoder().decode(e.Payload));if(console.log("NAT Gateway manager response:",r),r.statusCode!==200)throw new Error(`NAT Gateway restore failed: ${r.error}`);console.log("NAT Gateway restore completed")}async function C(t,a,s,e){let r=process.env.STATE_TABLE_NAME||"GarmaxAi-ResourceState";await U.send(new g.PutCommand({TableName:r,Item:{resourceKey:t,timestamp:Date.now(),stage:a,currentState:s,metadata:e,ttl:Math.floor(Date.now()/1e3)+2160*60*60}}))}async function k(t,a,s){let e=process.env.SNS_TOPIC_ARN;if(!e)return;let r=`\u2705 GarmaxAI ${t} Environment Restore Completed

\u{1F4CA} Restore Summary:
\u2022 Duration: ${Math.floor(s/60)}m ${s%60}s
\u2022 RDS Status: ${a.rds?.status||"N/A"}
\u2022 ElastiCache Status: ${a.elasticache?.status||"N/A"}
\u2022 ECS Services: ${a.ecs?.servicesRestored||0} restored
\u2022 NAT Gateway: ${a.natGateway?"Restored":"N/A"}

\u{1F680} System is ready for production traffic!

Timestamp: ${new Date().toISOString()}`;await V.send(new p.PublishCommand({TopicArn:e,Subject:`\u2705 GarmaxAI ${t} - Restore Completed`,Message:r}))}var M=async t=>{console.log("Restore orchestrator invoked:",JSON.stringify(t,null,2));let a=Date.now();try{let{resource:s,stage:e,wait:r=!1}=t,n={};switch(s){case"rds":n.rds=await N(e,r);break;case"elasticache":n.elasticache=await v(e,r);break;case"ecs":n.ecs=await $(e);break;case"nat-gateway":await y(e),n.natGateway=!0;break;case"all":let[m,d,f]=await Promise.all([N(e,r),v(e,r),$(e),y(e)]);n={rds:m,elasticache:d,ecs:f,natGateway:!0};break;default:throw new Error(`Unknown resource: ${s}`)}let o=[`/garmaxai/idle-state/${e}/timestamp`,`/garmaxai/idle-state/${e}/rds-cluster`,`/garmaxai/idle-state/${e}/redis-snapshot`,`/garmaxai/idle-state/${e}/ecs-services`];for(let m of o)await h.send(new c.DeleteParameterCommand({Name:m})).catch(()=>{});let i=Math.floor((Date.now()-a)/1e3);return await k(e,n,i),{statusCode:200,message:`Restore completed for ${s} in ${e}`,results:n,duration:i,timestamp:new Date().toISOString()}}catch(s){throw console.error("Restore orchestrator error:",s),s}};0&&(module.exports={handler});
//# sourceMappingURL=index.js.map
