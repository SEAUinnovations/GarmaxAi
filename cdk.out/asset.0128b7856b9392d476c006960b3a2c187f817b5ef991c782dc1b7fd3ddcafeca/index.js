"use strict";var y=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var R=Object.prototype.hasOwnProperty;var S=(e,a)=>{for(var o in a)y(e,o,{get:a[o],enumerable:!0})},D=(e,a,o,s)=>{if(a&&typeof a=="object"||typeof a=="function")for(let n of f(a))!R.call(e,n)&&n!==o&&y(e,n,{get:()=>a[n],enumerable:!(s=G(a,n))||s.enumerable});return e};var C=e=>D(y({},"__esModule",{value:!0}),e);var k={};S(k,{handler:()=>p});module.exports=C(k);var r=require("@aws-sdk/client-ec2"),u=require("@aws-sdk/client-ssm"),g=require("@aws-sdk/client-dynamodb"),T=require("@aws-sdk/lib-dynamodb"),w=new r.EC2Client({region:process.env.AWS_REGION||"us-east-1"}),I=new u.SSMClient({region:process.env.AWS_REGION||"us-east-1"}),A=T.DynamoDBDocumentClient.from(new g.DynamoDBClient({region:process.env.AWS_REGION||"us-east-1"})),c=process.env.STAGE||"DEV",N=process.env.STATE_TABLE||`garmaxai-resource-states-${c}`;var p=async e=>{console.log("NAT Gateway Manager invoked:",JSON.stringify(e,null,2));let a=e.action,o=e.vpcId||process.env.VPC_ID;if(!o)throw new Error("VPC ID is required");try{if(a==="teardown")return await _(o);if(a==="restore")return await b(o);throw new Error(`Unknown action: ${a}`)}catch(s){throw console.error("NAT Gateway Manager error:",s),await l("IDLE","IDLE",{error:String(s)}),s}};async function _(e){console.log(`Starting NAT Gateway teardown for VPC: ${e}`);let a=await m();if(a==="IDLE"||a==="NAT_DELETING")return console.log(`Already in state: ${a}, skipping teardown`),{status:"already_idle",currentState:a};await l("ACTIVE","TEARDOWN_INITIATED",{vpcId:e,timestamp:new Date().toISOString()});let o=await O(e);if(console.log(`Found ${o.length} NAT Gateways`),o.length===0)return console.log("No NAT Gateways found, marking as IDLE"),await l("TEARDOWN_INITIATED","IDLE",{}),{status:"no_nat_gateways"};let s=o.map(t=>({natGatewayId:t.NatGatewayId,allocationId:t.NatGatewayAddresses?.[0]?.AllocationId||"",subnetId:t.SubnetId}));await v(s);let n=await $(e,o.map(t=>t.NatGatewayId));console.log(`Found ${n.length} routes pointing to NAT Gateways`),await l("TEARDOWN_INITIATED","NAT_DELETING",{natGateways:s,routes:n});for(let t of s)console.log(`Deleting NAT Gateway: ${t.natGatewayId}`),await w.send(new r.DeleteNatGatewayCommand({NatGatewayId:t.natGatewayId}));await L(o.map(t=>t.NatGatewayId)),await l("NAT_DELETING","NAT_DELETED",{}),console.log("Updating route tables..."),await l("NAT_DELETED","ROUTES_UPDATING",{});for(let t of n)try{console.log(`Removing route: ${t.destinationCidrBlock} from ${t.routeTableId}`),await w.send(new r.DeleteRouteCommand({RouteTableId:t.routeTableId,DestinationCidrBlock:t.destinationCidrBlock}))}catch(i){console.log(`Route deletion skipped (might be auto-deleted): ${i.message}`)}return await l("ROUTES_UPDATING","IDLE",{teardownCompleted:new Date().toISOString()}),console.log("NAT Gateway teardown completed successfully"),{status:"success",natGatewaysDeleted:s.length,routesRemoved:n.length,elasticIPsPreserved:s.map(t=>t.allocationId)}}async function b(e){console.log(`Starting NAT Gateway restore for VPC: ${e}`);let a=await m();if(a==="ACTIVE")return console.log("Already ACTIVE, skipping restore"),{status:"already_active"};if(a!=="IDLE")throw new Error(`Cannot restore from state: ${a}`);await l("IDLE","RESTORE_INITIATED",{timestamp:new Date().toISOString()});let o=await h(),s=await V();if(!o||o.length===0)throw new Error("No NAT Gateway configurations found in Parameter Store");console.log(`Restoring ${o.length} NAT Gateways`),await l("RESTORE_INITIATED","NAT_CREATING",{});let n={};for(let i of o){console.log(`Creating NAT Gateway in subnet: ${i.subnetId}`);let d=await w.send(new r.CreateNatGatewayCommand({SubnetId:i.subnetId,AllocationId:i.allocationId,TagSpecifications:[{ResourceType:"natgateway",Tags:[{Key:"Name",Value:`garmaxai-nat-${c}`},{Key:"Environment",Value:c},{Key:"ManagedBy",Value:"IdleManager"},{Key:"RestoredAt",Value:new Date().toISOString()}]}]}));n[i.natGatewayId]=d.NatGateway.NatGatewayId,console.log(`Created new NAT Gateway: ${d.NatGateway.NatGatewayId}`)}await P(Object.values(n)),await l("NAT_CREATING","NAT_AVAILABLE",{newNATGateways:n}),console.log("Restoring routes..."),await l("NAT_AVAILABLE","ROUTES_RESTORING",{});let t=s?.routes||[];for(let i of t){let d=n[i.natGatewayId];if(!d){console.warn(`No new NAT Gateway ID found for old ID: ${i.natGatewayId}`);continue}try{console.log(`Creating route: ${i.destinationCidrBlock} -> ${d} in ${i.routeTableId}`),await w.send(new r.CreateRouteCommand({RouteTableId:i.routeTableId,DestinationCidrBlock:i.destinationCidrBlock,NatGatewayId:d}))}catch(E){console.error(`Failed to create route: ${E.message}`)}}return await l("ROUTES_RESTORING","ACTIVE",{restoreCompleted:new Date().toISOString(),natGateways:Object.values(n)}),console.log("NAT Gateway restore completed successfully"),{status:"success",natGatewaysCreated:Object.keys(n).length,routesRestored:t.length,newNATGateways:n}}async function O(e){return(await w.send(new r.DescribeNatGatewaysCommand({Filter:[{Name:"vpc-id",Values:[e]},{Name:"state",Values:["available"]}]}))).NatGateways||[]}async function $(e,a){let o=await w.send(new r.DescribeRouteTablesCommand({Filters:[{Name:"vpc-id",Values:[e]}]})),s=[];for(let n of o.RouteTables||[])for(let t of n.Routes||[])t.NatGatewayId&&a.includes(t.NatGatewayId)&&s.push({routeTableId:n.RouteTableId,destinationCidrBlock:t.DestinationCidrBlock,natGatewayId:t.NatGatewayId});return s}async function L(e){let o=0;for(;o<20;){if((await w.send(new r.DescribeNatGatewaysCommand({NatGatewayIds:e}))).NatGateways?.every(t=>t.State==="deleted")??!1){console.log("All NAT Gateways deleted successfully");return}console.log(`Waiting for NAT Gateways to delete... (attempt ${o+1}/20)`),await new Promise(t=>setTimeout(t,3e4)),o++}throw new Error("Timeout waiting for NAT Gateway deletion")}async function P(e){let o=0;for(;o<20;){if((await w.send(new r.DescribeNatGatewaysCommand({NatGatewayIds:e}))).NatGateways?.every(t=>t.State==="available")??!1){console.log("All NAT Gateways are now available");return}console.log(`Waiting for NAT Gateways to become available... (attempt ${o+1}/20)`),await new Promise(t=>setTimeout(t,3e4)),o++}throw new Error("Timeout waiting for NAT Gateway availability")}async function v(e){await I.send(new u.PutParameterCommand({Name:`/garmaxai/nat-gateway/${c}/config`,Value:JSON.stringify(e),Type:"String",Overwrite:!0,Description:`NAT Gateway configurations for ${c} idle restore`})),await I.send(new u.PutParameterCommand({Name:`/garmaxai/nat-gateway/${c}/eip-alloc-ids`,Value:e.map(a=>a.allocationId).join(","),Type:"StringList",Overwrite:!0,Description:`Elastic IP allocation IDs for ${c}`}))}async function h(){try{let e=await I.send(new u.GetParameterCommand({Name:`/garmaxai/nat-gateway/${c}/config`}));return JSON.parse(e.Parameter.Value)}catch(e){return console.error("Failed to retrieve NAT Gateway config:",e),[]}}async function l(e,a,o){let s=new Date().toISOString(),n=Math.floor(Date.now()/1e3)+2160*60*60;await A.send(new T.PutCommand({TableName:N,Item:{resourceKey:`NAT_GATEWAY#${c}`,timestamp:s,state:a,previousState:e,stage:c,metadata:o,ttl:n}})),console.log(`State updated: ${e} -> ${a}`)}async function m(){let e=await A.send(new T.QueryCommand({TableName:N,KeyConditionExpression:"resourceKey = :key",ExpressionAttributeValues:{":key":`NAT_GATEWAY#${c}`},ScanIndexForward:!1,Limit:1}));return e.Items&&e.Items.length>0?e.Items[0].state:"ACTIVE"}async function V(){let e=await A.send(new T.QueryCommand({TableName:N,KeyConditionExpression:"resourceKey = :key",ExpressionAttributeValues:{":key":`NAT_GATEWAY#${c}`},ScanIndexForward:!1,Limit:1}));return e.Items&&e.Items.length>0?e.Items[0].metadata||{}:{}}0&&(module.exports={handler});
//# sourceMappingURL=index.js.map
