{
  "version": 3,
  "sources": ["../../iac/lambda-handlers/natGatewayManager/index.ts"],
  "sourcesContent": ["import {\n  EC2Client,\n  DescribeNatGatewaysCommand,\n  DeleteNatGatewayCommand,\n  CreateNatGatewayCommand,\n  DescribeRouteTablesCommand,\n  DeleteRouteCommand,\n  CreateRouteCommand,\n  NatGateway,\n  RouteTable,\n} from '@aws-sdk/client-ec2';\nimport { SSMClient, PutParameterCommand, GetParameterCommand } from '@aws-sdk/client-ssm';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, PutCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';\n\nconst ec2Client = new EC2Client({ region: process.env.AWS_REGION || 'us-east-1' });\nconst ssmClient = new SSMClient({ region: process.env.AWS_REGION || 'us-east-1' });\nconst dynamoClient = DynamoDBDocumentClient.from(new DynamoDBClient({ region: process.env.AWS_REGION || 'us-east-1' }));\n\nconst STAGE = process.env.STAGE || 'DEV';\nconst STATE_TABLE = process.env.STATE_TABLE || `garmaxai-resource-states-${STAGE}`;\n\ninterface NATGatewayConfig {\n  natGatewayId: string;\n  allocationId: string;\n  subnetId: string;\n}\n\ninterface RouteConfig {\n  routeTableId: string;\n  destinationCidrBlock: string;\n  natGatewayId: string;\n}\n\nenum ResourceState {\n  ACTIVE = 'ACTIVE',\n  TEARDOWN_INITIATED = 'TEARDOWN_INITIATED',\n  NAT_DELETING = 'NAT_DELETING',\n  NAT_DELETED = 'NAT_DELETED',\n  ROUTES_UPDATING = 'ROUTES_UPDATING',\n  IDLE = 'IDLE',\n  RESTORE_INITIATED = 'RESTORE_INITIATED',\n  NAT_CREATING = 'NAT_CREATING',\n  NAT_AVAILABLE = 'NAT_AVAILABLE',\n  ROUTES_RESTORING = 'ROUTES_RESTORING',\n}\n\nexport const handler = async (event: any): Promise<any> => {\n  console.log('NAT Gateway Manager invoked:', JSON.stringify(event, null, 2));\n\n  const action = event.action; // 'teardown' or 'restore'\n  const vpcId = event.vpcId || process.env.VPC_ID;\n\n  if (!vpcId) {\n    throw new Error('VPC ID is required');\n  }\n\n  try {\n    if (action === 'teardown') {\n      return await teardownNATGateways(vpcId);\n    } else if (action === 'restore') {\n      return await restoreNATGateways(vpcId);\n    } else {\n      throw new Error(`Unknown action: ${action}`);\n    }\n  } catch (error) {\n    console.error('NAT Gateway Manager error:', error);\n    await updateState(ResourceState.IDLE, ResourceState.IDLE, { error: String(error) });\n    throw error;\n  }\n};\n\nasync function teardownNATGateways(vpcId: string): Promise<any> {\n  console.log(`Starting NAT Gateway teardown for VPC: ${vpcId}`);\n\n  // Check if already in teardown or idle state\n  const currentState = await getCurrentState();\n  if (currentState === ResourceState.IDLE || currentState === ResourceState.NAT_DELETING) {\n    console.log(`Already in state: ${currentState}, skipping teardown`);\n    return { status: 'already_idle', currentState };\n  }\n\n  await updateState(ResourceState.ACTIVE, ResourceState.TEARDOWN_INITIATED, {\n    vpcId,\n    timestamp: new Date().toISOString(),\n  });\n\n  // 1. Describe and save NAT Gateway configurations\n  const natGateways = await describeNATGateways(vpcId);\n  console.log(`Found ${natGateways.length} NAT Gateways`);\n\n  if (natGateways.length === 0) {\n    console.log('No NAT Gateways found, marking as IDLE');\n    await updateState(ResourceState.TEARDOWN_INITIATED, ResourceState.IDLE, {});\n    return { status: 'no_nat_gateways' };\n  }\n\n  const natConfigs: NATGatewayConfig[] = natGateways.map((ng) => ({\n    natGatewayId: ng.NatGatewayId!,\n    allocationId: ng.NatGatewayAddresses?.[0]?.AllocationId || '',\n    subnetId: ng.SubnetId!,\n  }));\n\n  // Save NAT Gateway configurations to Parameter Store\n  await saveNATGatewayConfig(natConfigs);\n\n  // 2. Get route tables before deleting NAT Gateways\n  const routeConfigs = await getRoutesPointingToNAT(vpcId, natGateways.map((ng) => ng.NatGatewayId!));\n  console.log(`Found ${routeConfigs.length} routes pointing to NAT Gateways`);\n\n  // Save route configurations to DynamoDB for restore\n  await updateState(ResourceState.TEARDOWN_INITIATED, ResourceState.NAT_DELETING, {\n    natGateways: natConfigs,\n    routes: routeConfigs,\n  });\n\n  // 3. Delete NAT Gateways\n  for (const natConfig of natConfigs) {\n    console.log(`Deleting NAT Gateway: ${natConfig.natGatewayId}`);\n    await ec2Client.send(\n      new DeleteNatGatewayCommand({\n        NatGatewayId: natConfig.natGatewayId,\n      })\n    );\n  }\n\n  // 4. Poll for deletion completion\n  await pollNATGatewayDeletion(natGateways.map((ng) => ng.NatGatewayId!));\n\n  await updateState(ResourceState.NAT_DELETING, ResourceState.NAT_DELETED, {});\n\n  // 5. Remove routes (they should be automatically removed, but clean up if needed)\n  console.log('Updating route tables...');\n  await updateState(ResourceState.NAT_DELETED, ResourceState.ROUTES_UPDATING, {});\n\n  for (const routeConfig of routeConfigs) {\n    try {\n      console.log(`Removing route: ${routeConfig.destinationCidrBlock} from ${routeConfig.routeTableId}`);\n      await ec2Client.send(\n        new DeleteRouteCommand({\n          RouteTableId: routeConfig.routeTableId,\n          DestinationCidrBlock: routeConfig.destinationCidrBlock,\n        })\n      );\n    } catch (error: any) {\n      // Route might already be deleted automatically\n      console.log(`Route deletion skipped (might be auto-deleted): ${error.message}`);\n    }\n  }\n\n  await updateState(ResourceState.ROUTES_UPDATING, ResourceState.IDLE, {\n    teardownCompleted: new Date().toISOString(),\n  });\n\n  console.log('NAT Gateway teardown completed successfully');\n  return {\n    status: 'success',\n    natGatewaysDeleted: natConfigs.length,\n    routesRemoved: routeConfigs.length,\n    elasticIPsPreserved: natConfigs.map((c) => c.allocationId),\n  };\n}\n\nasync function restoreNATGateways(vpcId: string): Promise<any> {\n  console.log(`Starting NAT Gateway restore for VPC: ${vpcId}`);\n\n  // Check current state\n  const currentState = await getCurrentState();\n  if (currentState === ResourceState.ACTIVE) {\n    console.log('Already ACTIVE, skipping restore');\n    return { status: 'already_active' };\n  }\n\n  if (currentState !== ResourceState.IDLE) {\n    throw new Error(`Cannot restore from state: ${currentState}`);\n  }\n\n  await updateState(ResourceState.IDLE, ResourceState.RESTORE_INITIATED, {\n    timestamp: new Date().toISOString(),\n  });\n\n  // 1. Retrieve saved configurations\n  const natConfigs = await getNATGatewayConfig();\n  const stateData = await getStateData();\n\n  if (!natConfigs || natConfigs.length === 0) {\n    throw new Error('No NAT Gateway configurations found in Parameter Store');\n  }\n\n  console.log(`Restoring ${natConfigs.length} NAT Gateways`);\n\n  await updateState(ResourceState.RESTORE_INITIATED, ResourceState.NAT_CREATING, {});\n\n  // 2. Recreate NAT Gateways\n  const newNATGateways: { [oldId: string]: string } = {};\n\n  for (const natConfig of natConfigs) {\n    console.log(`Creating NAT Gateway in subnet: ${natConfig.subnetId}`);\n    const result = await ec2Client.send(\n      new CreateNatGatewayCommand({\n        SubnetId: natConfig.subnetId,\n        AllocationId: natConfig.allocationId, // Reuse the preserved Elastic IP\n        TagSpecifications: [\n          {\n            ResourceType: 'natgateway',\n            Tags: [\n              { Key: 'Name', Value: `garmaxai-nat-${STAGE}` },\n              { Key: 'Environment', Value: STAGE },\n              { Key: 'ManagedBy', Value: 'IdleManager' },\n              { Key: 'RestoredAt', Value: new Date().toISOString() },\n            ],\n          },\n        ],\n      })\n    );\n\n    newNATGateways[natConfig.natGatewayId] = result.NatGateway!.NatGatewayId!;\n    console.log(`Created new NAT Gateway: ${result.NatGateway!.NatGatewayId}`);\n  }\n\n  // 3. Wait for NAT Gateways to become available\n  await pollNATGatewayAvailability(Object.values(newNATGateways));\n\n  await updateState(ResourceState.NAT_CREATING, ResourceState.NAT_AVAILABLE, {\n    newNATGateways,\n  });\n\n  // 4. Restore routes\n  console.log('Restoring routes...');\n  await updateState(ResourceState.NAT_AVAILABLE, ResourceState.ROUTES_RESTORING, {});\n\n  const routeConfigs: RouteConfig[] = stateData?.routes || [];\n\n  for (const routeConfig of routeConfigs) {\n    const newNATGatewayId = newNATGateways[routeConfig.natGatewayId];\n    if (!newNATGatewayId) {\n      console.warn(`No new NAT Gateway ID found for old ID: ${routeConfig.natGatewayId}`);\n      continue;\n    }\n\n    try {\n      console.log(\n        `Creating route: ${routeConfig.destinationCidrBlock} -> ${newNATGatewayId} in ${routeConfig.routeTableId}`\n      );\n      await ec2Client.send(\n        new CreateRouteCommand({\n          RouteTableId: routeConfig.routeTableId,\n          DestinationCidrBlock: routeConfig.destinationCidrBlock,\n          NatGatewayId: newNATGatewayId,\n        })\n      );\n    } catch (error: any) {\n      console.error(`Failed to create route: ${error.message}`);\n      // Continue with other routes even if one fails\n    }\n  }\n\n  await updateState(ResourceState.ROUTES_RESTORING, ResourceState.ACTIVE, {\n    restoreCompleted: new Date().toISOString(),\n    natGateways: Object.values(newNATGateways),\n  });\n\n  console.log('NAT Gateway restore completed successfully');\n  return {\n    status: 'success',\n    natGatewaysCreated: Object.keys(newNATGateways).length,\n    routesRestored: routeConfigs.length,\n    newNATGateways,\n  };\n}\n\n// Helper functions\n\nasync function describeNATGateways(vpcId: string): Promise<NatGateway[]> {\n  const result = await ec2Client.send(\n    new DescribeNatGatewaysCommand({\n      Filter: [\n        { Name: 'vpc-id', Values: [vpcId] },\n        { Name: 'state', Values: ['available'] },\n      ],\n    })\n  );\n  return result.NatGateways || [];\n}\n\nasync function getRoutesPointingToNAT(vpcId: string, natGatewayIds: string[]): Promise<RouteConfig[]> {\n  const result = await ec2Client.send(\n    new DescribeRouteTablesCommand({\n      Filters: [{ Name: 'vpc-id', Values: [vpcId] }],\n    })\n  );\n\n  const routeConfigs: RouteConfig[] = [];\n\n  for (const routeTable of result.RouteTables || []) {\n    for (const route of routeTable.Routes || []) {\n      if (route.NatGatewayId && natGatewayIds.includes(route.NatGatewayId)) {\n        routeConfigs.push({\n          routeTableId: routeTable.RouteTableId!,\n          destinationCidrBlock: route.DestinationCidrBlock!,\n          natGatewayId: route.NatGatewayId,\n        });\n      }\n    }\n  }\n\n  return routeConfigs;\n}\n\nasync function pollNATGatewayDeletion(natGatewayIds: string[]): Promise<void> {\n  const maxAttempts = 20; // 10 minutes (30 seconds * 20)\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    const result = await ec2Client.send(\n      new DescribeNatGatewaysCommand({\n        NatGatewayIds: natGatewayIds,\n      })\n    );\n\n    const allDeleted = result.NatGateways?.every((ng) => ng.State === 'deleted') ?? false;\n\n    if (allDeleted) {\n      console.log('All NAT Gateways deleted successfully');\n      return;\n    }\n\n    console.log(`Waiting for NAT Gateways to delete... (attempt ${attempts + 1}/${maxAttempts})`);\n    await new Promise((resolve) => setTimeout(resolve, 30000)); // 30 seconds\n    attempts++;\n  }\n\n  throw new Error('Timeout waiting for NAT Gateway deletion');\n}\n\nasync function pollNATGatewayAvailability(natGatewayIds: string[]): Promise<void> {\n  const maxAttempts = 20;\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    const result = await ec2Client.send(\n      new DescribeNatGatewaysCommand({\n        NatGatewayIds: natGatewayIds,\n      })\n    );\n\n    const allAvailable = result.NatGateways?.every((ng) => ng.State === 'available') ?? false;\n\n    if (allAvailable) {\n      console.log('All NAT Gateways are now available');\n      return;\n    }\n\n    console.log(`Waiting for NAT Gateways to become available... (attempt ${attempts + 1}/${maxAttempts})`);\n    await new Promise((resolve) => setTimeout(resolve, 30000));\n    attempts++;\n  }\n\n  throw new Error('Timeout waiting for NAT Gateway availability');\n}\n\nasync function saveNATGatewayConfig(configs: NATGatewayConfig[]): Promise<void> {\n  await ssmClient.send(\n    new PutParameterCommand({\n      Name: `/garmaxai/nat-gateway/${STAGE}/config`,\n      Value: JSON.stringify(configs),\n      Type: 'String',\n      Overwrite: true,\n      Description: `NAT Gateway configurations for ${STAGE} idle restore`,\n    })\n  );\n\n  // Also save EIP allocation IDs separately for easy reference\n  await ssmClient.send(\n    new PutParameterCommand({\n      Name: `/garmaxai/nat-gateway/${STAGE}/eip-alloc-ids`,\n      Value: configs.map((c) => c.allocationId).join(','),\n      Type: 'StringList',\n      Overwrite: true,\n      Description: `Elastic IP allocation IDs for ${STAGE}`,\n    })\n  );\n}\n\nasync function getNATGatewayConfig(): Promise<NATGatewayConfig[]> {\n  try {\n    const result = await ssmClient.send(\n      new GetParameterCommand({\n        Name: `/garmaxai/nat-gateway/${STAGE}/config`,\n      })\n    );\n    return JSON.parse(result.Parameter!.Value!);\n  } catch (error) {\n    console.error('Failed to retrieve NAT Gateway config:', error);\n    return [];\n  }\n}\n\nasync function updateState(previousState: ResourceState, newState: ResourceState, metadata: any): Promise<void> {\n  const timestamp = new Date().toISOString();\n  const ttl = Math.floor(Date.now() / 1000) + 90 * 24 * 60 * 60; // 90 days\n\n  await dynamoClient.send(\n    new PutCommand({\n      TableName: STATE_TABLE,\n      Item: {\n        resourceKey: `NAT_GATEWAY#${STAGE}`,\n        timestamp,\n        state: newState,\n        previousState,\n        stage: STAGE,\n        metadata,\n        ttl,\n      },\n    })\n  );\n\n  console.log(`State updated: ${previousState} -> ${newState}`);\n}\n\nasync function getCurrentState(): Promise<ResourceState> {\n  const result = await dynamoClient.send(\n    new QueryCommand({\n      TableName: STATE_TABLE,\n      KeyConditionExpression: 'resourceKey = :key',\n      ExpressionAttributeValues: {\n        ':key': `NAT_GATEWAY#${STAGE}`,\n      },\n      ScanIndexForward: false, // Get most recent first\n      Limit: 1,\n    })\n  );\n\n  if (result.Items && result.Items.length > 0) {\n    return result.Items[0].state as ResourceState;\n  }\n\n  return ResourceState.ACTIVE; // Default state\n}\n\nasync function getStateData(): Promise<any> {\n  const result = await dynamoClient.send(\n    new QueryCommand({\n      TableName: STATE_TABLE,\n      KeyConditionExpression: 'resourceKey = :key',\n      ExpressionAttributeValues: {\n        ':key': `NAT_GATEWAY#${STAGE}`,\n      },\n      ScanIndexForward: false,\n      Limit: 1,\n    })\n  );\n\n  if (result.Items && result.Items.length > 0) {\n    return result.Items[0].metadata || {};\n  }\n\n  return {};\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "handler", "__toCommonJS", "import_client_ec2", "import_client_ssm", "import_client_dynamodb", "import_lib_dynamodb", "ec2Client", "ssmClient", "dynamoClient", "STAGE", "STATE_TABLE", "handler", "event", "action", "vpcId", "teardownNATGateways", "restoreNATGateways", "error", "updateState", "currentState", "getCurrentState", "natGateways", "describeNATGateways", "natConfigs", "ng", "saveNATGatewayConfig", "routeConfigs", "getRoutesPointingToNAT", "natConfig", "ec2Client", "pollNATGatewayDeletion", "routeConfig", "c", "getNATGatewayConfig", "stateData", "getStateData", "newNATGateways", "result", "STAGE", "pollNATGatewayAvailability", "newNATGatewayId", "natGatewayIds", "routeTable", "route", "attempts", "resolve", "configs", "ssmClient", "previousState", "newState", "metadata", "timestamp", "ttl", "dynamoClient", "STATE_TABLE"]
}
