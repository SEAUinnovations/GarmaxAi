{
  "version": 3,
  "sources": ["../../iac/lambda-handlers/teardownOrchestrator/index.ts"],
  "sourcesContent": ["import { RDSClient, StopDBClusterCommand, DescribeDBClustersCommand } from '@aws-sdk/client-rds';\nimport {\n  ElastiCacheClient,\n  CreateSnapshotCommand,\n  DeleteCacheClusterCommand,\n  DescribeCacheClustersCommand,\n} from '@aws-sdk/client-elasticache';\nimport { ECSClient, UpdateServiceCommand, ListServicesCommand } from '@aws-sdk/client-ecs';\nimport { LambdaClient, InvokeCommand } from '@aws-sdk/client-lambda';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, PutCommand } from '@aws-sdk/lib-dynamodb';\nimport { SSMClient, PutParameterCommand } from '@aws-sdk/client-ssm';\n\nconst rdsClient = new RDSClient({});\nconst elasticacheClient = new ElastiCacheClient({});\nconst ecsClient = new ECSClient({});\nconst lambdaClient = new LambdaClient({});\nconst ddbClient = DynamoDBDocumentClient.from(new DynamoDBClient({}));\nconst ssmClient = new SSMClient({});\n\ninterface TeardownEvent {\n  resource: 'rds' | 'elasticache' | 'ecs' | 'nat-gateway' | 'all';\n  stage: string;\n  vpcId?: string;\n  clusterId?: string;\n  redisClusterId?: string;\n  ecsCluster?: string;\n}\n\n/**\n * Stop RDS Aurora cluster\n */\nasync function stopRDS(stage: string, clusterId: string): Promise<void> {\n  console.log(`Stopping RDS cluster: ${clusterId}`);\n\n  // Check current status\n  const describeResponse = await rdsClient.send(\n    new DescribeDBClustersCommand({\n      DBClusterIdentifier: clusterId,\n    })\n  );\n\n  const status = describeResponse.DBClusters?.[0]?.Status;\n  if (status === 'stopped') {\n    console.log(`RDS cluster already stopped`);\n    return;\n  }\n\n  if (status !== 'available') {\n    throw new Error(`Cannot stop RDS cluster in status: ${status}`);\n  }\n\n  // Stop the cluster\n  await rdsClient.send(\n    new StopDBClusterCommand({\n      DBClusterIdentifier: clusterId,\n    })\n  );\n\n  // Store cluster ID in Parameter Store\n  await ssmClient.send(\n    new PutParameterCommand({\n      Name: `/garmaxai/idle-state/${stage}/rds-cluster`,\n      Value: clusterId,\n      Type: 'String',\n      Overwrite: true,\n    })\n  );\n\n  // Update DynamoDB state\n  await updateResourceState(`RDS_CLUSTER#${stage}`, stage, 'STOPPING', {\n    clusterId,\n    stoppedAt: new Date().toISOString(),\n  });\n\n  console.log(`RDS cluster stop initiated: ${clusterId}`);\n}\n\n/**\n * Snapshot and delete ElastiCache cluster\n */\nasync function teardownElastiCache(stage: string, redisClusterId: string): Promise<void> {\n  console.log(`Tearing down ElastiCache cluster: ${redisClusterId}`);\n\n  // Check if cluster exists\n  const describeResponse = await elasticacheClient.send(\n    new DescribeCacheClustersCommand({\n      CacheClusterId: redisClusterId,\n    })\n  ).catch(() => null);\n\n  if (!describeResponse || !describeResponse.CacheClusters || describeResponse.CacheClusters.length === 0) {\n    console.log(`ElastiCache cluster not found, skipping`);\n    return;\n  }\n\n  const clusterStatus = describeResponse.CacheClusters[0].CacheClusterStatus;\n  if (clusterStatus !== 'available') {\n    console.log(`ElastiCache cluster not available (status: ${clusterStatus}), skipping`);\n    return;\n  }\n\n  // Create snapshot for PROD before deletion\n  if (stage === 'PROD') {\n    const snapshotName = `garmaxai-redis-${stage}-idle-${Date.now()}`;\n    console.log(`Creating snapshot: ${snapshotName}`);\n\n    await elasticacheClient.send(\n      new CreateSnapshotCommand({\n        CacheClusterId: redisClusterId,\n        SnapshotName: snapshotName,\n      })\n    );\n\n    // Store snapshot name in Parameter Store\n    await ssmClient.send(\n      new PutParameterCommand({\n        Name: `/garmaxai/idle-state/${stage}/redis-snapshot`,\n        Value: snapshotName,\n        Type: 'String',\n        Overwrite: true,\n      })\n    );\n\n    // Wait a few seconds for snapshot to initialize\n    await new Promise((resolve) => setTimeout(resolve, 5000));\n  }\n\n  // Delete the cluster\n  await elasticacheClient.send(\n    new DeleteCacheClusterCommand({\n      CacheClusterId: redisClusterId,\n    })\n  );\n\n  // Update DynamoDB state\n  await updateResourceState(`ELASTICACHE#${stage}`, stage, 'DELETING', {\n    clusterId: redisClusterId,\n    deletedAt: new Date().toISOString(),\n    snapshotCreated: stage === 'PROD',\n  });\n\n  console.log(`ElastiCache cluster deletion initiated: ${redisClusterId}`);\n}\n\n/**\n * Scale down ECS services\n */\nasync function scaleDownECS(stage: string, ecsCluster: string): Promise<void> {\n  console.log(`Scaling down ECS services in cluster: ${ecsCluster}`);\n\n  // List all services\n  const listResponse = await ecsClient.send(\n    new ListServicesCommand({\n      cluster: ecsCluster,\n    })\n  );\n\n  if (!listResponse.serviceArns || listResponse.serviceArns.length === 0) {\n    console.log(`No ECS services found in cluster`);\n    return;\n  }\n\n  // Store service ARNs for restore\n  await ssmClient.send(\n    new PutParameterCommand({\n      Name: `/garmaxai/idle-state/${stage}/ecs-services`,\n      Value: listResponse.serviceArns.join(','),\n      Type: 'StringList',\n      Overwrite: true,\n    })\n  );\n\n  // Scale each service to 0\n  for (const serviceArn of listResponse.serviceArns) {\n    const serviceName = serviceArn.split('/').pop()!;\n    console.log(`Scaling service to 0: ${serviceName}`);\n\n    await ecsClient.send(\n      new UpdateServiceCommand({\n        cluster: ecsCluster,\n        service: serviceName,\n        desiredCount: 0,\n      })\n    );\n  }\n\n  // Update DynamoDB state\n  await updateResourceState(`ECS_CLUSTER#${stage}`, stage, 'SCALED_DOWN', {\n    cluster: ecsCluster,\n    serviceCount: listResponse.serviceArns.length,\n    scaledDownAt: new Date().toISOString(),\n  });\n\n  console.log(`Scaled down ${listResponse.serviceArns.length} ECS services`);\n}\n\n/**\n * Invoke NAT Gateway manager for teardown\n */\nasync function teardownNATGateway(stage: string, vpcId: string): Promise<void> {\n  console.log(`Invoking NAT Gateway manager for VPC: ${vpcId}`);\n\n  const functionName = process.env.NAT_MANAGER_FUNCTION_NAME || `GarmaxAi-NATManager-${stage}`;\n\n  const response = await lambdaClient.send(\n    new InvokeCommand({\n      FunctionName: functionName,\n      Payload: JSON.stringify({\n        action: 'teardown',\n        vpcId,\n      }),\n    })\n  );\n\n  const result = JSON.parse(new TextDecoder().decode(response.Payload));\n  console.log(`NAT Gateway manager response:`, result);\n\n  if (result.statusCode !== 200) {\n    throw new Error(`NAT Gateway teardown failed: ${result.error}`);\n  }\n\n  console.log(`NAT Gateway teardown completed`);\n}\n\n/**\n * Update resource state in DynamoDB\n */\nasync function updateResourceState(resourceKey: string, stage: string, state: string, metadata: any): Promise<void> {\n  const stateTableName = process.env.STATE_TABLE_NAME || 'GarmaxAi-ResourceState';\n\n  await ddbClient.send(\n    new PutCommand({\n      TableName: stateTableName,\n      Item: {\n        resourceKey,\n        timestamp: Date.now(),\n        stage,\n        currentState: state,\n        metadata,\n        ttl: Math.floor(Date.now() / 1000) + 90 * 24 * 60 * 60, // 90 days\n      },\n    })\n  );\n}\n\n/**\n * Lambda handler\n */\nexport const handler = async (event: TeardownEvent): Promise<any> => {\n  console.log('Teardown orchestrator invoked:', JSON.stringify(event, null, 2));\n\n  try {\n    const { resource, stage } = event;\n\n    // Record teardown start time\n    await ssmClient.send(\n      new PutParameterCommand({\n        Name: `/garmaxai/idle-state/${stage}/timestamp`,\n        Value: new Date().toISOString(),\n        Type: 'String',\n        Overwrite: true,\n      })\n    );\n\n    switch (resource) {\n      case 'rds':\n        if (!event.clusterId) throw new Error('clusterId required for RDS teardown');\n        await stopRDS(stage, event.clusterId);\n        break;\n\n      case 'elasticache':\n        if (!event.redisClusterId) throw new Error('redisClusterId required for ElastiCache teardown');\n        await teardownElastiCache(stage, event.redisClusterId);\n        break;\n\n      case 'ecs':\n        if (!event.ecsCluster) throw new Error('ecsCluster required for ECS teardown');\n        await scaleDownECS(stage, event.ecsCluster);\n        break;\n\n      case 'nat-gateway':\n        if (!event.vpcId) throw new Error('vpcId required for NAT Gateway teardown');\n        await teardownNATGateway(stage, event.vpcId);\n        break;\n\n      case 'all':\n        // Execute all teardowns in parallel for efficiency\n        await Promise.all([\n          event.clusterId ? stopRDS(stage, event.clusterId) : Promise.resolve(),\n          event.redisClusterId ? teardownElastiCache(stage, event.redisClusterId) : Promise.resolve(),\n          event.ecsCluster ? scaleDownECS(stage, event.ecsCluster) : Promise.resolve(),\n          event.vpcId ? teardownNATGateway(stage, event.vpcId) : Promise.resolve(),\n        ]);\n        break;\n\n      default:\n        throw new Error(`Unknown resource: ${resource}`);\n    }\n\n    return {\n      statusCode: 200,\n      message: `Teardown completed for ${resource} in ${stage}`,\n      timestamp: new Date().toISOString(),\n    };\n  } catch (error) {\n    console.error('Teardown orchestrator error:', error);\n    throw error;\n  }\n};\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "handler", "__toCommonJS", "import_client_rds", "import_client_elasticache", "import_client_ecs", "import_client_lambda", "import_client_dynamodb", "import_lib_dynamodb", "import_client_ssm", "rdsClient", "elasticacheClient", "ecsClient", "lambdaClient", "ddbClient", "ssmClient", "stopRDS", "stage", "clusterId", "status", "updateResourceState", "teardownElastiCache", "redisClusterId", "describeResponse", "clusterStatus", "snapshotName", "resolve", "scaleDownECS", "ecsCluster", "listResponse", "serviceArn", "serviceName", "teardownNATGateway", "vpcId", "functionName", "response", "result", "resourceKey", "state", "metadata", "stateTableName", "event", "resource", "error"]
}
